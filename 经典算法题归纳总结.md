

# 经典题目归纳总结

### 1.数组

#### 二分查找代码模板

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 我们定义target在左闭右开的区间里，[left, right)  
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        return right;
    }
};

```



- 二分法

  [第35题：搜索插入位](https://leetcode-cn.com/problems/search-insert-position/)

- 双指针法

  [第27题： 移除元素](https://leetcode-cn.com/problems/remove-element/)

- 滑动窗口

  [第209题：长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/ )

- 模拟行为

  [第59题：螺旋矩阵II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

### 2.链表

#### 定义链表结构（c++）

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
```



- 虚拟头节点

  [题目203：移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

- 链表常见的5个操作

  [第707题：设计链表](https://leetcode-cn.com/problems/design-linked-list/)

- 双指针翻转列表，也可递归

  [第206题：翻转单列表](https://leetcode-cn.com/problems/reverse-linked-list/)

- 快慢指针，找环，找入口

  [第142题：环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

### 3.哈希表

- 数组就是简单的哈希，数组的大小是受限的

  [第242题：有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

- 哈希值太大，还是用set

  [第349题. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

- 用set判断快乐数

  [第202题. 快乐数](https://leetcode-cn.com/problems/happy-number/)

- map记录两个值

  [第一题：两数之和](https://leetcode-cn.com/problems/two-sum/)

- 巧用map，先解决两个数

  [第454题.四数相加II](https://leetcode-cn.com/problems/4sum-ii/)

- 利用数组解决，与字母异位词类似
  
  [第383题. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

- 双指针更合适，注意去重操作
  [第15题. 三数之和](https://leetcode-cn.com/problems/3sum/)

- 与上题思路相同，双指针法

  [第18题. 四数之和](https://leetcode-cn.com/problems/4sum/)

### 4.字符串

- 简单地翻转，不能使用reverse

  [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

- 可使用reverse库函数

  [第541题. 反转字符串II](https://leetcode-cn.com/problems/reverse-string-ii/)

- 先给数组扩容，再从后向前操作（双指针法）

  [剑指Offer 05.替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

- 双指针，实现库函数

  [第151题：翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

- 局部反转+整体反转

  [剑指Offer58-II.左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

#### KMP 构建前缀表c++代码

```c++
void getNext (int* next, const string& s) {
    int j = -1; // 前缀表统一减一版本
    next[0] = -1;
    for (int i = 1; i < s.size(); i++) {
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j];
        }
        if (s[i] == s[j + 1]) {
            j++;
        }
        next[i] = j;
    }
}
```

```c++
void getNext (int* next, const string& s) {
    int j = 0; // 前缀表不减一版本
    next[0] = 0;
    for (int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) {
            j = next[j - 1];
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
```



- KMP算法，构建next数组

  [实现strStr()](https://leetcode-cn.com/problems/implement-strstr/)

- 巧用KMP判断重复字符串

  [第459题.重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/submissions/)

### 5.双指针法

### 6.栈与队列

- 用队列实现栈

  [第225题.用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

- 用栈解决对称匹配

  [第20题.有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

- 把字符串导入栈中

  [第1047题. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

- 用栈解决

  [第150题. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

- 手动实现单调队列解决滑动窗口问题

  [第239题. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

- 优先级队列与堆

  [第347题.前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

### 7.二叉树

####    分类

- **满二叉树**：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上（深度为k，有2^k-1个节点）；
- **完全二叉树**：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置；
- **二叉搜索树：**
  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  - 它的左、右子树也分别为二叉排序树；
- **平衡二叉树：**一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；

####    存储方式

- 链式存储（指针）
- 顺序存储（数组）[**如果父节点的数组下表是i，那么它的左孩子就是i \* 2 + 1，右孩子就是 i \* 2 + 2。**]

####    遍历方式

- 深度优先遍历
  - 前序遍历（中左右）
  - 中序遍历（左中右）
  - 后序遍历（左右中）
- 广度优先遍历
  - 层次遍历

####    二叉树定义c++代码

链式存储：

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

#### 深度优先遍历（递归）代码模板

**前序遍历（中左右）**

```c++
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
```

**中序遍历（左中右）**

```c++
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->right, vec); // 右
}
```

**后序遍历（左右中）**

```c++
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
}
```

#### 深度优先遍历（迭代用栈）代码模板

**前序遍历（中左右）**

```c++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);                          
        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

**中序遍历（左中右）**

```c++
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

            st.push(node);                          // 添加中节点
            st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

            if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();           // 将空节点弹出
            node = st.top();    // 重新取出栈中元素
            st.pop();
            result.push_back(node->val); // 加入到结果集
          }
        }
        return result;
}
```

**后序遍历（左右中）**

```c++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);                          // 中
            st.push(NULL);
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左

        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

#### 广度优先遍历（迭代用队列）代码模板

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {// 这里一定要使用固定大小size，不要使用que.size()
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);   // 节点处理的逻辑
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}
```

- 广度优先遍历

  [第102题.二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/)

- 自底向上的层次遍历，最后加一个翻转就可

  [107.二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

- 判断是否遍历到单层最后一个元素，是就放进res中

  [第199题.二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

- 求平均值

  [第637题.二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

- N叉树层级遍历

  [第429题.N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

#### 二叉树的属性

- 递归或者迭代

  [第101题. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

- 二叉树最大深度，迭代模板题

  [第104题.二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

- N叉树最大深度，迭代模板题

  [第559题.N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/submissions/)

- 二叉树的最小深度

  [第111题.二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/submissions/)

- 二叉树节点数量，套模板

  [第222题.完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

- 平不平衡看高度，递归效率更高

  [第110题.平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/submissions/)

- 求路径，递归体现回溯，也可迭代

  [第257题. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

- 通过该节点的父节点判断该节点的属性

  [第404题.左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

- 广度优先搜索迭代简单

  [第513题.找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

- 回溯递归，深度优先搜索，搜索一条符合要求的路径即可

  [第112题. 路径总和](https://leetcode-cn.com/problems/path-sum/submissions/)

- 回溯递归，深度优先搜索，搜索所有路径，找出所有符合的路径

  [第113题. 路径总和II](https://leetcode-cn.com/problems/path-sum-ii/)

#### 二叉树深度代码

```c++
int getDepth(TreeNode* node) {
    if (node == NULL) return 0;
    return 1 + max(getDepth(node->left), getDepth(node->right));
}
```

#### 二叉树节点数量代码

```c++
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

### 8.动态规划

### 9.回溯算法

####     代码模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

